<!DOCTYPE html>
<header>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BigView</title>
  <link rel="stylesheet" href="css/foundation.css">
  <link rel="stylesheet" href="css/app.css">
</header>
<script src="d3.v3.min.js" charset="utf-8"></script>
<script src="underscore.js" charset="utf-8"></script>

<script>
  var main_colors = ["#a50026", "#d73027", "#f46d43", "#fdae61", "#fee08b", "#ffffbf", "#d9ef8b", "#a6d96a", "#66bd63", "#1a9850", "#00aa00", "rgb(255, 215, 0)"]
  var main_colors = ['#800026',
    '#bd0026',
    '#e31a1c',
    '#fc4e2a',
    '#fd8d3c',
    '#feb24c',
    '#fed976',
    '#ffeda0',
    '#ffffcc', "#f7fbff", "#deebf7", "#c6dbef", "#9ecae1", "#6baed6", "#4292c6", "#2171b5", "#08519c", "#08306b", '#3f007d',
    '#54278f',
    '#6a51a3',
    '#807dba',
    '#9e9ac8',
    '#bcbddc',
    '#dadaeb',
    '#efedf5',
    '#fcfbfd'
  ]


  function randomArray(length, max) {
    return Array.apply(null, Array(length)).map(function(_, i) {
      return Math.round(Math.random() * max);
    });
  }

  var flag = ['#00441b',
      '#006d2c',
      '#238b45',
      '#41ab5d',
      '#74c476',
      '#a1d99b',
      '#c7e9c0',
      '#e5f5e0',
      '#f7fcf5'
    ]
    //var main_colors = ["#df65b0","#e7298a","#ce1256","#980043"]




  //The SVG Container
  var treeContainer = d3.select("body").append("svg")
    .attr("width", 600)
    .attr("height", 800);
  var svgContainer = d3.select("body").append("svg")
    .attr("width", 600)
    .attr("height", 600)
    .style("margin-top", 20)
    .append("g")
    .attr("transform", "translate(300,300)");

  var Gs = svgContainer.selectAll("g")



  var last_ihours = false
  var background_painted = false
  var text_labels
  var last_hours_positions
  var existing_arcs = []
  var previously_itemized_values = []
  var itemized_values_indexed = {}
  var divitions
  var percentage_elapsed
  var saved_data
  var circle_percentage_elapsed
  var seconds_circle
  var seconds_circle_color = 'yellow'
  var pending_timeouts = []
  var itemized_values = {}


  var generateBall = function(data, radio, ihours, type, assigned_colors, update_count) {

    console.log('generateBall')

    if (type == undefined) {
      var maxVal = 0
      var scaleit
    } else {
      var maxVal = []
      var scaleit = []
    }

    // updating to_rotate
    function update_cicle_percentage() {
      var currentDate = new Date()
      var miliseconds_at_midnight = new Date(currentDate.getUTCFullYear() + '-' + (currentDate.getMonth() + 1) + '-' + currentDate.getDate())
      var miliseconds_elapsed = currentDate.getTime() - miliseconds_at_midnight.getTime()
      var circle_percentage_elapsed = miliseconds_elapsed / (1000 * 60 * 60 * 24)

      if (ihours == 1) {
        var miliseconds_at_last_hour = new Date(currentDate.getUTCFullYear() + '-' + (currentDate.getMonth() + 1) + '-' + currentDate.getDate() + ' ' + currentDate.getHours() + ':00:00')
        var miliseconds_elapsed = currentDate.getTime() - miliseconds_at_midnight.getTime()
        var circle_percentage_elapsed = miliseconds_elapsed / (1000 * 60 * 60)
      }
      return circle_percentage_elapsed

    }

    var to_rotate = update_cicle_percentage() * 360

    // if there is no background circle, paint it, only once
    if (!background_painted) {
      var circle = svgContainer.append('circle')
        .attr('id', 'circleBG')
        .attr('r', radio)
        .attr('cx', 0)
        .attr('cy', 0)
        .attr('fill', '#222222');

      seconds_circle = svgContainer.append('circle')
        .attr('id', 'runningCircle')
        .attr('r', 3)
        .attr('cx', 0)
        .attr('cy', -295)
        .attr('fill', 'grey')
        .attr("transform", "rotate(" + to_rotate + ") ")
      var second_count = 30

      // automatically update every second the updating yellow
      setInterval(function() {
        // console.log(second_count)
        second_count--
        if (second_count < 0) {
          second_count = 30
        }
        if (seconds_circle_color.indexOf('yellow') > -1) {
          seconds_circle_color = 'grey'
        } else {
          seconds_circle_color = 'yellow'
        }
        var to_rotate = update_cicle_percentage() * 360
        seconds_circle
          .attr('fill', seconds_circle_color)
          .attr("transform", "rotate(" + to_rotate + ") ")

      }, 1000)
      background_painted = true

    }




    // paint hour marks
    if (last_ihours != ihours) {

      if (ihours == 24) {
        var hours = _.range(24);
        var hours_positions = _.map(hours, function(hour) {
          var angle = hour / 24 * 2 * Math.PI;
          if (hour.toString().length == 1) {
            hour = '0' + hour
          }
          return {
            cx: -(radio * 0.93) * Math.sin(angle),
            cy: (radio * 0.95) * Math.cos(angle),
            text: hour + ':00'
          }
        })
      } else {
        var num = 12
        var hours = _.range(num);
        var minutes = 0
        var hours_positions = _.map(hours, function(hour) {
          var angle = hour / num * 2 * Math.PI;
          var minutes = hour * (60 / num)
          var now = new Date()

          if (minutes.toString().length == 1) {
            minutes = '0' + minutes
          }
          left_hour = ""
          if (now.getHours().toString().length == 1) {
            left_hour = "0"
          }

          return {
            cx: (radio * 0.93) * Math.sin(angle),
            cy: -(radio * 0.95) * Math.cos(angle),
            text: left_hour + now.getHours() + ":" + minutes
          }
        })
      }

      if (last_ihours == false) {
        text_labels = svgContainer.selectAll("text")
          .data(hours_positions)
          .enter()
          .append("text");

        text_labels
          .attr("x", function(d) {
            return d.cx;
          })
          .attr("y", function(d) {
            return d.cy;
          })
          .text(function(d) {
            return d.text;
          })
          .attr("font-family", "sans-serif")
          .attr("font-size", (10 / 300 * radio) + "px")
          .attr("fill", "white")
          .attr("text-anchor", "middle")

        last_hours_positions = hours_positions

      } else {
        if (last_ihours == 1 && ihours == 24) {
          only_hour = []
          _.each(hours_positions, function(value, index) {
            if (value.text == last_hours_positions[0].text) {
              only_hour.push(value)
            }
          })
        }

        text_labels
          .data(only_hour)
          .exit() //.transition()
          // .duration(1000)
          //.attr("fill", "black")
          .remove()

        text_labels
          .data(only_hour)
          .transition()
          .duration(2000)
          .attr("x", function(d) {
            return d.cx;
          })
          .attr("y", function(d) {
            return d.cy;
          })
          .text(function(d) {
            if (d != undefined) {
              return d.text;
            } else {
              return 'd.text';

            }
          })

        new_hours_positions = only_hour
        _.each(hours_positions, function(each, pos) {
          if (each.text != only_hour[0].text) {
            new_hours_positions.push(each);
          }
        })

        text_labels = svgContainer.selectAll("text")
          .data(new_hours_positions)
          .enter()
          .append("text")
          .attr("x", function(d) {
            return d.cx;
          })
          .attr("y", function(d) {
            return d.cy;
          })
          .text(function(d) {
            return d.text;
          })
          .attr("font-family", "sans-serif")
          .attr("font-size", (10 / 300 * radio) + "px")
          .attr("fill", "white")
          .attr("transform", "translate(" + (radio * 0.95) + "," + (radio * 1.005) + ")");
      }
      last_ihours = ihours
    }

    // if we are automatically updating do not update the percentage_elapsed
    if (update_count > 0) {

    } else {
      divitions = data.length;
      percentage_elapsed = update_cicle_percentage()
      var currentDate = new Date()
    }


    // end of background and hour marks

    // start processing data and paint it

    // get the columns that come in the data by checking the first row
    var items = Object.keys(data[0])
    console.log(items)

    items = _.sortBy(items, function(d) {
      return d
    })

    var total_values = {}
      // calculate all scales
    _.map(items, function(item, itemIndex) {

      if (update_count == 0) {
        saved_data = data
        var updated_data = data
      } else {
        var position_to_change = saved_data.length - (update_count)
        saved_data[position_to_change][item] = data[0][item]
        var updated_data = saved_data
      }

      var itemized_data_values = _.map(updated_data, function(eachdata) {
        if (eachdata[item] != undefined) {
          if (eachdata[item]['max_val'] > 0) {
            return eachdata[item]['max_val']
          } else {
            return eachdata[item]['value']
          }
        } else {
          return 1;
        }
      })


      // if type is undefined, they all share the same scale
      if (type == undefined) {
        if (maxVal == undefined) {
          maxVal = 0
        }
        maxVal += d3.max(itemized_data_values)

        scaleit = d3.scale.linear()
          .domain([0, maxVal])
          .range([0, radio * 0.90]);

      } else {
        // else, type must be 'twin' and each has its own scale
        if (maxVal[itemIndex] == undefined) {
          maxVal[itemIndex] = 0
        }
        maxVal[itemIndex] += d3.max(itemized_data_values)
        scaleit[itemIndex] = d3.scale.linear()
          .domain([0, maxVal[itemIndex]])
          .range([0, radio * 0.90]);
      }

    })


    // generate itemized values for scales
    itemized_values = {}
    _.map(items, function(item, itemIndex) {

        itemized_values[itemIndex] = []

        if (update_count == 0) {
          updated_data = data
        } else {
          updated_data = saved_data
        }
        var itemized_data = _.map(updated_data, function(eachdata) {
          return eachdata[item]
        })

        var pos = 0;
        for (i = 2 * Math.PI; pos < divitions; i = i - 2 * Math.PI / divitions) {
          if (itemized_data[pos] != undefined && typeof(itemized_data[pos]['value']) == 'number') {
            if (total_values[pos] == undefined) {
              total_values[pos] = 0
            }

            if (type == undefined) {
              value = scaleit(itemized_data[pos]['value'])
            } else {
              value = scaleit[itemIndex](itemized_data[pos]['value'])
            }

            if (value < 0) {
              value = 0
            }

            var decrease_transparency = ((pos + update_count) / (divitions))
            decrease_transparency = decrease_transparency - parseInt(decrease_transparency)

            itemized_values[itemIndex].push({
              "i": i,
              "pos": pos,
              "item": item,
              "itemIndex": itemIndex,
              "value": value,
              "previousValue": total_values[pos],
              "transparency": 1  - decrease_transparency + 0.3
            })
            total_values[pos] = total_values[pos] + value
          }
          pos++;

        }
        var to_rotate = -180 + percentage_elapsed * 360
        if (ihours == 1) {
          var to_rotate = percentage_elapsed * 360
        }



      })


      function paint_arcs(itemized_values, radio, to_rotate) {
        if (type == undefined) {
          var arc = d3.svg.arc()
            .innerRadius(function(d) {
              // return d.previousValue
              return d.previousValue;
            })
            .outerRadius(function(d) {
              return d.value + d.previousValue;
            })
            .startAngle(function(d) {
              return d.i
            })
            .endAngle(function(d) {
              return d.i + 2 * Math.PI / (divitions)
            });
        } else {
          var arc = d3.svg.arc()
            .innerRadius(function(d) {
              return 0;
            })
            .outerRadius(function(d) {
              return d.value;
            })
            .startAngle(function(d) {
              return d.i + (2 * Math.PI / (divitions) / 2) * (d.itemIndex - 1)
            })
            .endAngle(function(d) {
              return d.i + 2 * Math.PI / (divitions) / 2 + (2 * Math.PI / (divitions) / 2) * (d.itemIndex - 1)
            });
        }

        // console.log('itemized_values_indexed')
        // console.log(itemized_values_indexed)
        // console.log('items.length')
        // console.log(items)
        // console.log(items.length)
        // console.log('itemized_values_indexed.length')
        // console.log(Object.keys(itemized_values_indexed))
        // console.log(Object.keys(itemized_values_indexed).length)

        // var deleting_length = Object.keys(itemized_values_indexed).length
        // for(i = items.length ; i < deleting_length ; i++){
        //   console.log(i)
        //   console.log('deleting: '+i)
        //   delete itemized_values_indexed[i]
        // }

        // console.log('itemized_values_indexed')
        // console.log(Object.keys(itemized_values_indexed))

        all_itemized_values = []
        _.each(itemized_values, function(each_itemized_values) {
          _.each(each_itemized_values, function(each_each) {
            all_itemized_values.push(each_each)
          })
        });

        /// copying functioning one
        var svgarcs = svgContainer.selectAll("path")

        arcs = svgarcs.data(all_itemized_values, function(d) {
          return "" + d.pos + d.itemIndex
        });

        // UPDATE
        // Update old elements as needed.
        arcs.attr("class", "update")
          .transition()
          .duration(1000)
          .attr("d", arc)
          .attr("transform", "rotate(" + to_rotate + ") ")
          .delay(function(d) {
            return d.pos * 10
          })
          .attr("opacity", function(d) {
            return d.transparency
          })

        // ENTER
        // Create new elements as needed.
        arcs.enter().append('path')
          .attr('fill', function(d) {
            return assigned_colors[d.itemIndex]
          })
          .attr("transform", "rotate(" + to_rotate + ") ")
          .attr("opacity", function(d) {
            return d.transparency
          })
          .on('click', function(d) {
            console.log(d)
          })
          .transition()
          .delay(function(d) {
            return d.pos * 10
          })
          .attr("d", arc)
          .attr("opacity", function(d) {
            return d.transparency
          })

        // EXIT
        // Remove old elements as needed.
        arcs.exit()
          .attr("class", "exit")
          .transition()
          .duration(3000)
          .attr("opacity", 0)
          .remove();

      }

      paint_arcs(itemized_values, radio, to_rotate)

  }


  var user = {
    name: 'Carlos Guerrero',
    services: [{
      name: 'Mediahint',
      servers: [{
          longview: '88F48041-B897-A5FB-88B706D42D45A501',
          pm2: 'holaproxy1'
        }, {
          longview: '88F48041-B897-A5FB-88B706D42D45A502',
          pm2: 'holaproxy2'
        }, {
          longview: '88F48041-B897-A5FB-88B706D42D45A503',
          pm2: 'holaproxy3'
        }, {
          longview: '88F48041-B897-A5FB-88B706D42D45A504',
          pm2: 'holaproxy4'
        }, {
          longview: '88F48041-B897-A5FB-88B706D42D45A505',
          pm2: 'holaproxy5'
        },
        // {
        //   longview: '88F48041-B897-A5FB-88B706D42D45A506',
        //   pm2: 'holaproxy6'
        // },
        {
          longview: '88F48041-B897-A5FB-88B706D42D45A507',
          pm2: 'holaproxy7'
        }, {
          longview: '88F48041-B897-A5FB-88B706D42D45A508',
          pm2: 'holaproxy8'
        }, {
          longview: '88F48041-B897-A5FB-88B706D42D45A509',
          pm2: 'holaproxy9'
        }, {
          longview: '88F48041-B897-A5FB-88B706D42D45A510',
          pm2: 'holaproxy10'
        }




      ]
    }]
  }

  var config = {
    ball_radius: 300
  }

  var servers_graphs = {}


  function get_last_hour_of(server) {
    // server_list = _.map(user.services[0].servers, function(each) {
    //   return each.longview
    // })
    // server_list = ['88F48041-B897-A5FB-88B706D42D45A502']
    var server_list = []
    server_list.push(server)
    _.each(server_list, function(value, key, list) {
      servers_logs = []
      d3.json("http://longview.carlosguerrero.com:8090/get/" + value + "/" + (120), function(err, server_logs) {
        if (server_logs.length > 100)
          servers_logs = []
        server_logs.reverse()
        _.each(server_logs, function(value, key, list) {

          if (servers_logs[key] == undefined) {
            servers_logs[key] = {}
          }

          servers_logs[key][value.apikey] = {
            value: value.Memory_real_used,
            id: value.apikey + value.timestamp
          };
        })
        generateBall(servers_logs, config.ball_radius, 1, main_colors)
      })
    })
  }

  function get_of(server_list, server_keys, hours, type, colors, fake_hours) {
    var update_count = -1
    _.each(pending_timeouts, function(each_timeout) {
      clearTimeout(each_timeout)
    })
    var count = 1
    var orig_nvalues
    var trigger_get_of = function(update) {

      _.each(server_list, function(value, list_key, list) {

        servers_logs = []
        var nvalues
        if (update) {
          nvalues = 1
          if (fake_hours > 1) {
            nvalues = fake_hours
          }
        } else {
          nvalues = (120 * hours)
          orig_nvalues = nvalues
        }
        if (update_count > orig_nvalues) {
          update_count = 0;
        }


        var url = "http://longview.carlosguerrero.com:8090/get/" + value + "/" + nvalues
        console.log(url)
        d3.json(url, function(err, server_logs) {
          //server_logs.reverse()


          function process_logs(server_logs, servers_logs) {
            var missing = nvalues - servers_logs.length
            _.each(server_keys, function(each_server_key) {

              if (fake_hours > 0) {
                if (update) {
                  rate = fake_hours // 4
                } else {
                  rate = hours / fake_hours // 4
                }

                var summingit = 0
                var count = 0
                var apikey = ""

                new_server_logs = []
                  //console.log(server_logs)
                  //_.each(Object.keys(server_logs[0]), function(each_key) {
                _.each(server_logs, function(value, key, list) {
                    summingit = summingit + value[each_server_key]
                    apikey = value['apikey']
                    count++
                    if (count >= rate) {
                      var new_value = {}
                      new_value[each_server_key] = summingit / rate
                      new_value['apikey'] = apikey
                      new_server_logs.push(new_value)
                      count = 0
                      summingit = 0
                    }
                  })
                  //})

                server_logs = new_server_logs
                  //console.log(server_logs)

                //console.log(server_logs.length)
              }

              _.each(server_logs, function(value, key, list) {

                if (servers_logs[key] == undefined) {
                  servers_logs[key] = {}
                }
                var max_val = 0
                if (each_server_key.indexOf('Mem') > -1) {
                  max_val = value.Memory_real_used + value.Memory_real_free
                }

                if (each_server_key.indexOf('load') > -1) {
                  max_val = 1.30
                }

                servers_logs[key][value.apikey + each_server_key] = {
                  value: value[each_server_key],
                  max_val: max_val
                };
              })

            })
            return servers_logs
          }


          servers_logs = process_logs(server_logs, servers_logs)

          // if (update_count > 0) {
          //if(server_list.length == servers_logs.length){
          console.log(Object.keys(servers_logs[0]).length)
          console.log(server_list.length)
            // if(Object.keys(servers_logs[0]).length == server_list.length){
          generateBall(servers_logs, config.ball_radius, 1, type, colors, update_count)

          // }
          //}
          // } else {
          //   // setTimeout(function(){
          //     generateBall(servers_logs, config.ball_radius, 1, type, colors, update_count)
          //   // }, 2000*count)
          // }


        })


      })

      if (fake_hours > 1) {
        var update_seconds = 30 * fake_hours
      } else {
        var update_seconds = 30
      }

      // pending_timeouts.push(setTimeout(function() {
      //   console.log("triggering automatic update... get of")
      //   trigger_get_of(true)
      // }, update_seconds * 1000))

      update_count++

    }

    trigger_get_of(false)

  }





  function get_last_day() {
    // server_list = _.map(user.services[0].servers, function(each){ return each.longview})
    server_list = _.map(user.services[0].servers, function(each) {
      return each.longview
    })
    server_list = ['88F48041-B897-A5FB-88B706D42D45A502']

    _.each(server_list, function(value, key, list) {
      servers_logs = []
      d3.json("http://longview.carlosguerrero.com:8090/get/" + value + "/" + (2880), function(err, server_logs) {
        if (server_logs.length > 100)
          servers_logs = []
        server_logs.reverse()
        _.each(server_logs, function(value, key, list) {
          if (servers_logs[key] == undefined) {
            servers_logs[key] = {}
          }
          servers_logs[key][value.apikey] = {
            value: value.Memory_real_used,
            id: value.apikey + value.timestamp
          };
        })
        generateBall(servers_logs, config.ball_radius, 24)
      })
    })
  }

  function nodes_tree(width, height) {


    var tree_container = treeContainer.selectAll("text.title").data(user.services)
      .enter().append('text')

    var textLabels = tree_container
      .attr("x", function(d, i) {
        return 10
      })
      .attr("y", function(d, i) {
        return 30 + 40 * i;
      })
      .text(function(d, i) {
        return d.name;
      })
      .attr("font-family", "sans-serif")
      .attr("font-size", "20px")
      .attr("fill", "white")


    _.each(user.services, function(service) {
      servers_vertical_separation = 80

      var tree_container = treeContainer.selectAll("text.server").data(service.servers)
        .enter().append('g').append('text')

      var textLabels = tree_container
        .attr("x", function(d, i) {
          return 20
        })
        .attr("y", function(d, i) {
          return 60 + servers_vertical_separation * i;
        })
        .text(function(d, i) {
          return d.pm2;
        })
        .attr("font-family", "sans-serif")
        .attr("font-size", "20px")
        .attr("fill", "grey")
        .on("click", function(d, i) {
          // get_last_hour_of(d.longview)
          var test_list = []
          test_list.push(d.longview)
          get_of(test_list, ['load', 'Memory_real_used'], 1, 'twin', ["rgb(255, 215, 0)", "#00aa00"])
        })

      var tree_container_colors = treeContainer.selectAll("rect.server").data(service.servers)
        .enter().append('rect')

      tree_container_colors
        .attr('x', 10)
        .attr('y', function(d, i) {
          return 40 + servers_vertical_separation * i
        })
        .attr('height', 79)
        .attr('width', 5)
        .style('fill', function(d, i) {
          return main_colors[i]
        })


      // servers graphs
      // each of the servers
      servers_graphs_array = []
      servers_graphs = {}
      ports_list_containers = []
      ips_container = []
      details_painted = {}
      details_list_containers = {}


      function update_values_every(timeout, servers, key, order) {
        var painted = false;
        var tree_container = {}
        var labels_container = {}
        var items = [{
            key: "load",
            pos: 0
          }, {
            key: "Memory_real_used",
            pos: 1
          }, {
            //   key: "swap",
            //   pos: 1
            // }, {
            key: "rx_Kbps",
            pos: 2
          }, {
            key: "tx_Kbps",
            pos: 3
          }, {
            key: "ports",
            pos: 4,
            type: 'text'
          }, {
            key: "details",
            type: "details"
          }]
          // var items = [{key: "load", pos: 0}, {key: "memory", pos:1}]

        if (painted == false) {
          _.each(items, function(item) {
            var key = item.key
            var type = item.type
            _.each(servers, function(each_server) {
              // populate initial empty graphs with proper key IDs for right visual order
              servers_graphs_array.push(each_server)
              servers_graphs[each_server.longview] = each_server
            });

            if (type != undefined && type.indexOf('text') > -1) {

            } else {
              tree_container[key] = treeContainer.selectAll("bar." + key).data(servers_graphs_array, function(d) {
                  return d.longview
                })
                .enter().append('rect')

              tree_container[key].attr("x", 150)
                .attr("y", function(d, i) {
                  return 45 + servers_vertical_separation * i;
                })
                .attr("width", 0)
                .attr("height", 10)
                .on('click', function(d) {
                  console.log(d)
                  if (key.indexOf('Mem') > -1) {
                    bars_color = 'rgb(255, 215, 0)'
                  } else {
                    bars_color = '#00aa00'
                  }
                  get_of([d.apikey], [key], 1, undefined, [bars_color])
                })

              labels_container[key] = treeContainer.selectAll("label." + key).data(servers_graphs_array, function(d) {
                  return d.longview
                })
                .enter().append('text').attr("font-size", "8.5px")



              labels_container[key].attr("x", 150)
                .attr("y", function(d, i) {
                  return 45 + servers_vertical_separation * i;
                })
                .attr('text-anchor', 'end')



            }
          })

          painted = true
        }

        function update_now() {

          _.each(servers, function(each_server) {

            d3.json("http://longview.carlosguerrero.com:8090/get/" + each_server.longview + "/1",
              function(err, server_log) {

                _.each(items, function(item) {

                  key = item.key
                  order = item.pos
                  type = item.type

                  if (type != undefined && type.indexOf('text') > -1) {
                    // if is text, is the ports list


                  } else {

                    if (type == undefined) {

                      var bar_max_width = width * 0.5
                      servers_graphs[each_server.longview] = server_log[0]
                      servers_graphs[each_server.longview].longview = servers_graphs[each_server.longview].apikey
                      servers_graphs_array = []
                      _.each(servers_graphs, function(each) {
                          servers_graphs_array.push(each)
                        })
                        //
                      tree_container[key].data(servers_graphs_array, function(d) {
                          return d.longview
                        })
                        .transition().attr("x", 150)
                        .attr("y", function(d, i) {
                          return 45 + servers_vertical_separation * i + (10 * order);
                        })
                        .attr("width", function(d, i) {
                          if (d.timestamp) {
                            if (key.indexOf('Mem') > -1) {
                              var memory_total = d.Memory_real_free + d.Memory_real_used
                              return (d.Memory_real_used / memory_total * bar_max_width)
                            }
                            if (key.indexOf('swap') > -1) {
                              var memory_total = d.Memory_real_free + d.Memory_real_used
                              return (d.Memory_swap_used / memory_total * bar_max_width)
                            }
                            if (key.indexOf('Kbps') > -1) {
                              return d[key] / 100000 * bar_max_width
                            }
                            return d[key] * bar_max_width
                          } else {
                            return 1
                          }
                        })
                        .style("fill", function() {
                          // var flag = ["#7f3b08","#b35806","#e08214","#fdb863","#fee0b6","#f7f7f7","#d8daeb","#b2abd2","#8073ac","#542788","#2d004b"]

                          if (key.indexOf('load') > -1) {
                            return flag[0];
                          }
                          if (key.indexOf('Mem') > -1) {
                            return flag[1];
                          }
                          if (key.indexOf('swap') > -1) {
                            return flag[1];
                          }
                          if (key.indexOf('rx') > -1) {
                            return flag[2];
                          }
                          if (key.indexOf('tx') > -1) {
                            return flag[3];
                          }
                        })
                        .attr("height", 10);
                      var local_result

                      labels_container[key].data(servers_graphs_array, function(d) {
                          return d.longview
                        }).transition()
                        .attr("y", function(d, i) {
                          return 52 + servers_vertical_separation * i + (10 * order);
                        })
                        .attr("x", function(d, i) {
                          if (d.timestamp) {
                            if (key.indexOf('Mem') > -1) {
                              var memory_total = d.Memory_real_free + d.Memory_real_used
                              return 150 + (d.Memory_real_used / memory_total * bar_max_width)
                            }
                            if (key.indexOf('swap') > -1) {
                              var memory_total = d.Memory_real_free + d.Memory_real_used
                              return 150 + (d.Memory_swap_used / memory_total * bar_max_width)
                            }
                            if (key.indexOf('Kbps') > -1) {
                              return 150 + d[key] / 100000 * bar_max_width
                            }
                            if (key.indexOf('load') > -1) {
                              return 150 + d[key] * bar_max_width
                            }
                          } else {
                            return 1
                          }
                        })
                        .attr('text-anchor', function(d, i) {

                          var val
                          if (d.timestamp) {
                            if (key.indexOf('Mem') > -1) {
                              var memory_total = d.Memory_real_free + d.Memory_real_used
                              val = (d.Memory_real_used / memory_total * bar_max_width)
                            }
                            if (key.indexOf('swap') > -1) {
                              var memory_total = d.Memory_real_free + d.Memory_real_used
                              val = (d.Memory_swap_used / memory_total * bar_max_width)
                            }
                            if (key.indexOf('Kbps') > -1) {

                              val = d[key] / 80000 * bar_max_width
                            }
                            if (key.indexOf('load') > -1) {
                              val = d[key] * bar_max_width
                            }
                          } else {
                            val = 1
                          }

                          if (val > 80) {
                            return 'end'
                          } else {
                            return 'start'
                          }

                        })

                      .style('fill', 'white')
                        .text(function(d) {
                          var val
                          if (d.timestamp) {
                            if (key.indexOf('Mem') > -1) {
                              var memory_total = d.Memory_real_free + d.Memory_real_used
                              val = (d.Memory_real_used / memory_total * bar_max_width)
                            }
                            if (key.indexOf('swap') > -1) {
                              var memory_total = d.Memory_real_free + d.Memory_real_used
                              val = (d.Memory_swap_used / memory_total * bar_max_width)
                            }
                            if (key.indexOf('Kbps') > -1) {
                              val = d[key] / 1000 * bar_max_width
                            }
                            if (key.indexOf('load') > -1) {
                              val = d[key] * bar_max_width
                            }
                          } else {
                            val = 1
                          }
                          var unit = '%'
                          if (key.indexOf('Kbps') > -1) {
                            unit = 'Mbps'
                            val = val / 100
                          }
                          return key + ": " + parseInt(val / bar_max_width * 100) + unit

                        })

                    } else {
                      if (type.indexOf('details') > -1) {
                        var this_server = server_log[0].apikey //.replace(/-/g,'')
                        var pos = Object.keys(servers_graphs).indexOf(each_server.longview)


                        //moving here the ports info generation

                        server_log[0].Ports_listening = _.sortBy(server_log[0].Ports_listening, function(each) {
                          return each.port
                        })

                        _.each(server_log[0].Ports_listening, function(each) {
                          each.pos = pos
                        })
                        ports_better_data_text = ""

                        _.each(server_log[0].Ports_listening, function(each_port) {
                          if (each_port.ip.indexOf('127.0.0.1') == -1) {
                            ports_better_data_text += each_port.name.split(" ")[0] + "(" + each_port.port + ") "
                          }
                        })

                        details = []
                        details.push(server_log[0].SysInfo_os_distversion + " " + server_log[0].SysInfo_type + " " + server_log[0].SysInfo_arch)
                        details.push(server_log[0].SysInfo_kernel)
                        details.push(server_log[0].SysInfo_cpu_type)
                        details.push("Opened ports: " + ports_better_data_text)


                        if (details_list_containers[this_server] == undefined) {
                          details_list_containers[this_server] = treeContainer.selectAll("text.details" + this_server)
                            .data(details)
                            .enter().append('text')

                          this_details_list_container = details_list_containers[this_server]
                        } else {
                          this_details_list_container = details_list_containers[this_server]
                            .data(details).transition()
                        }

                        this_details_list_container.attr("y", 10).attr("font-size", "9px")
                          .attr("x", function(d, i) {
                            return 20
                          })
                          .attr("y", function(d, i) {
                            //return 50 + servers_vertical_separation * i + (10 * order);

                            return pos * servers_vertical_separation + 68 + 10 + 10 * i
                          })
                          .style("fill", 'white')
                          .text(function(d) {
                            return d
                          })
                          // .append("svg:title").text(function(d){return d.name + " ("+d.type+" "+d.ip+":"+d.port+") "+d.user });



                      }
                    }


                  }


                })


              })
          })

          setTimeout(function() {
            update_now()
          }, timeout * 1000)
        }
        update_now()

      }


      update_values_every(30, service.servers, 'load', 0)

    })
  }

  function get_all_last_hour_bandwidth2() {
    server_list = _.map(user.services[0].servers, function(each) {
        return each.longview
      })
      //server_list = [server_list[0]]
      //server_list = [server_list[0]]
    server_list = server_list.slice(1, 4)
    get_of(server_list, ['tx_Kbps'], 1, undefined, main_colors)
  }

  function get_all_last_day_bandwidth2() {
    server_list = _.map(user.services[0].servers, function(each) {
      return each.longview
    })
    server_list = server_list.slice(1, 4)

    get_of(server_list, ['tx_Kbps'], 2, undefined, main_colors, 2)
  }

  window.onload = function() {
    var button = document.getElementById('change1')
    button.addEventListener("click", function() {
      console.log('click action...')
      get_all_last_day_bandwidth2()
    })

    var button = document.getElementById('allbandwidth')
    button.addEventListener("click", function() {
      get_all_last_hour_bandwidth2()
    })

    test_list = ['88F48041-B897-A5FB-88B706D42D45A504']
      //get_of(test_list, ['load', 'Memory_real_used'], 1)
    nodes_tree(600, 600)
    get_all_last_hour_bandwidth2()

  }
</script>

<body style="background-color:black;">
  <button id="change1" type="button" class="alert button">24h</button>
  <button id="allbandwidth" type="button" class="alert button">All</button>
</body>
